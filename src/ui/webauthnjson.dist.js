!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = e || self).webauthnJSON = {}) }(this, function (e) { "use strict"; function t(e) { const t = "==".slice(0, (4 - e.length % 4) % 4), n = e.replace(/-/g, "+").replace(/_/g, "/") + t, r = atob(n), i = new ArrayBuffer(r.length), a = new Uint8Array(i); for (let e = 0; e < r.length; e++)a[e] = r.charCodeAt(e); return i } function n(e) { const t = new Uint8Array(e); let n = ""; for (const e of t) n += String.fromCharCode(e); return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") } const r = "copy", i = "convert"; function a(e, t, n) { if (t === r) return n; if (t === i) return e(n); if (t instanceof Array) return n.map(n => a(e, t[0], n)); if (t instanceof Object) { const r = {}; for (const [i, o] of Object.entries(t)) if (i in n) null != n[i] ? r[i] = a(e, o.schema, n[i]) : r[i] = null; else if (o.required) throw new Error(`Missing key: ${i}`); return r } } function o(e) { return { required: !0, schema: e } } function c(e) { return { required: !1, schema: e } } const s = { type: o(r), id: o(i), transports: c(r) }, u = { publicKey: o({ rp: o(r), user: o({ id: o(i), name: o(r), displayName: o(r), icon: c(r) }), challenge: o(i), pubKeyCredParams: o(r), timeout: c(r), excludeCredentials: c([s]), authenticatorSelection: c(r), attestation: c(r), extensions: c(r) }), signal: c(r) }, l = { type: o(r), id: o(r), rawId: o(i), response: o({ clientDataJSON: o(i), attestationObject: o(i) }) }, d = { unmediated: c(r), mediation: c(r), publicKey: o({ challenge: o(i), timeout: c(r), rpId: c(r), allowCredentials: c([s]), userVerification: c(r), extensions: c(r) }), signal: c(r) }, f = { type: o(r), id: o(r), rawId: o(i), response: o({ clientDataJSON: o(i), authenticatorData: o(i), signature: o(i), userHandle: o(i) }) }, p = { credentialCreationOptions: u, publicKeyCredentialWithAttestation: l, credentialRequestOptions: d, publicKeyCredentialWithAssertion: f }; e.create = async function (e) { const r = a(t, u, e), i = await navigator.credentials.create(r); return a(n, l, i) }, e.get = async function (e) { const r = a(t, d, e), i = await navigator.credentials.get(r); return a(n, f, i) }, e.schema = p, e.supported = function () { return !!(navigator.credentials && navigator.credentials.create && navigator.credentials.get && window.PublicKeyCredential) }, Object.defineProperty(e, "__esModule", { value: !0 }) });
